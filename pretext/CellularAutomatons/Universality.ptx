<?xml version="1.0"?>
<section xml:id="cellular-automatons_universality">
  <title>Universality</title>
  <p>To understand universality, we have to understand computability theory, which is about models of computation and what they compute.</p>
  <p>One of the most general models of computation is the Turing machine, which is an abstract computer proposed by Alan Turing in 1936. A Turing machine is a 1-D CA, infinite in both directions, augmented with a read-write head. At any time, the head is positioned over a single cell. It can read the state of that cell (usually there are only two states) and it can write a new value into the cell.</p>
  <p>In addition, the machine has a register, which records the state of the machine (one of a finite number of states), and a table of rules. For each machine state and cell state, the table specifies an action. Actions include modifying the cell the head is over and moving one cell to the left or right.</p>
  <p>A Turing machine is not a practical design for a computer, but it models common computer architectures. For a given program running on a real computer, it is possible (at least in principle) to construct a Turing machine that performs an equivalent computation.</p>
  <p>The Turing machine is useful because it is possible to characterize the set of functions that can be computed by a Turing machine, which is what Turing did. Functions in this set are called <q>Turing computable</q>.</p>
  <p>To say that a Turing machine can compute any Turing-computable function is a tautology: it is true by definition. But Turing-computability is more interesting than that.</p>
  <p>It turns out that just about every reasonable model of computation anyone has come up with is <q>Turing complete</q>; that is, it can compute exactly the same set of functions as the Turing machine. Some of these models, like lamdba calculus, are very different from a Turing machine, so their equivalence is surprising.</p>
  <p>This observation led to the <term>Church-Turing Thesis</term>, which is the claim that these definitions of computability capture something essential that is independent of any particular model of computation.</p>
  <p>The Rule 110 CA is yet another model of computation, and remarkable for its simplicity. That it, too, turns out to be Turing complete lends support to the Church-Turing Thesis.</p>
  <p>In <em>A New Kind of Science</em>, Wolfram states a variation of this thesis, which he calls the <q>principle of computational equivalence</q>:</p>
  <p>Almost all processes that are not obviously simple can be viewed as computations of equivalent sophistication.
            More specifically, the principle of computational equivalence says that systems found in the natural world can perform computations up to a maximal (<q>universal</q>) level of computational power, and that most systems do in fact attain this maximal level of computational power. Consequently, most systems are computationally equivalent.</p>
  <p>Applying these definitions to CAs, Classes 1 and 2 are <q>obviously simple</q>. It may be less obvious that Class 3 is simple, but in a way perfect randomness is as simple as perfect order; complexity happens in between. So Wolfram's claim is that Class 4 behavior is common in the natural world, and that almost all systems that manifest it are computationally equivalent.</p>
  <exercise label="q1_6.8">
    <statement>
      <p>Q-1: The Turing machine is useful because it is possible to characterize the set of functions that can be computed by it.</p>
    </statement>
    <choices>
      <choice correct="yes">
        <statement>
          <p>True</p>
        </statement>
        <feedback>
          <p>Correct, it helps abstract what can be computed in general.</p>
        </feedback>
      </choice>
      <choice>
        <statement>
          <p>False</p>
        </statement>
        <feedback>
          <p>Incorrect, the Turning machine can help show what can and cannot be computed.</p>
        </feedback>
      </choice>
    </choices>
  </exercise>
</section>
